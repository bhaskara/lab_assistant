#!/usr/bin/env python

import sys
import yaml
import math
import os
import optparse
from os import path
import re
import time
import subprocess as sp
from sys import stderr
import shutil as sh

def param_range(r):
    if isinstance(r, list):
        return r
    elif isinstance(r, dict):
        a = r.get('min', 0)
        b = r['max']
        c = r.get('step', 1)
        return [a+c*i for i in range(1+int((b-a)/c)) if a+c*i<=b]
    else:
        return [r]

def param_combinations(ranges, i=0):
    if i==len(ranges):
        return [[]]
    k = ranges[i][0]
    vals = ranges[i][1]
    return [c + [(k, v)] for c in param_combinations(ranges, i+1) for v in vals]

def make_invocation(executable, params, outdir, file_params):
    p1 = ["--{0}={1}".format(k, v) for k, v in params.iteritems()]
    p2 = ["--{0}={1}".format(k, path.join(outdir, v)) for
          k, v in file_params.iteritems()]
    return [executable] + p1 + p2

def is_file_param(v):
    return isinstance(v, dict) and 'relative_path' in v

def get_file_params(config):
    l = [(k, v['relative_path']) for k, v in config['params'].iteritems() if
         is_file_param(v)]
    return dict(l)

def param_settings(config):
    ranges = [(n, param_range(v)) for n, v in config['params'].iteritems() if
              not is_file_param(v)]
    return map(dict, param_combinations(ranges))

def make_name(n):
    m = re.match('(.*)\.', n)
    if m:
        return m.group(1)
    else:
        return n

def get_time_stamp():
    return time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime())

def get_variable_params(config):
    l = [name for name, val in config['params'].iteritems() if\
         (isinstance(val, list) or isinstance(val, dict)) and
         not is_file_param(val)]
    l.sort()
    return l

def run_name(s, params):
    return '_'.join(str(s[p]) for p in params)

def setup_dirs(d, config_str):
    par = path.dirname(d)
    os.makedirs(d)
    latest = os.path.join(par, 'latest')
    if path.exists(latest):
        os.remove(latest)
    os.symlink(d, os.path.join(par, 'latest'))
    with open(path.join(d, 'config.yaml'), 'w') as f:
        f.write(config_str)

def process_vcs(config, path):
    vcs_config = config.get('vcs', None)
    if not vcs_config:
        return ''
    assert vcs_config['type'] == 'git'
    p = sp.Popen(['git', 'diff', '--stat'], stdout=sp.PIPE, cwd=path)
    out, err = p.communicate()
    assert not out.strip(), "Uncommitted changes in git repository: {0}".\
           format(out)
    p = sp.Popen(['git', 'rev-parse', 'HEAD'], stdout=sp.PIPE,
                 cwd=path)
    out, err = p.communicate()
    assert p.returncode==0
    return "vcs:\n  type: git\n  commit: {0}\n".format(out.strip())
    

def main():
    parser = optparse.OptionParser()
    parser.add_option('-l', '--log_dir', default=os.getenv('LAB_ASSISTANT_LOG_DIR', '.'))
    options, args = parser.parse_args()
    
    if len(args)<1:
        print "Usage: {0} CONFIG_FILE".format(sys.argv[0])
        return 1

    assert args[0]!='exp_info.yaml', "Forbidden name for config file"
    with open(args[0]) as f:
        config_str = f.read()
    config = yaml.load(config_str)

    name = config.get('name', make_name(args[0]))
    stamp = get_time_stamp()
    outdir = path.join(options.log_dir, name, stamp)
    stderr.write("Output dir is {0}\n".format(outdir))

    if os.path.exists(outdir):
        print "Directory {0} already exists".format(outdir)
        return 1

    config_dir = path.abspath(path.dirname(args[0]))
    vcs_info = process_vcs(config, config_dir)
    settings = param_settings(config)
    variable_params = get_variable_params(config)
    executable = path.join(config_dir, config['executable'])
    file_params = get_file_params(config)
    setup_dirs(outdir, config_str)
    with open(path.join(outdir, 'exp_info.yaml'), 'w') as f:
        f.write(vcs_info)
        f.write("executable: {0}\n".format(executable))

        for s in settings:
            d = os.path.join(outdir, run_name(s, variable_params))
            os.mkdir(d)
            for k, v in file_params.iteritems():
                parent = path.dirname(path.join(d, v))
                if not path.exists(parent):
                    os.makedirs(parent)
            with open(os.path.join(d, 'out.log'), 'w') as outfile:
                with open(os.path.join(d, 'err.log'), 'w') as errfile:
                    args = make_invocation(executable, s, d, file_params)
                    stderr.write("Running {0}... ".format(' '.join(args)))
                    try:
                        sp.check_call(args, stdout=outfile, stderr=errfile)
                        stderr.write("done\n")
                    except sp.CalledProcessError as e:
                        stderr.write("exited with return code {0}\n".\
                                     format(e.returncode))

        f.write("completed: true\n")

        
                
    
if __name__ == '__main__':
    sys.exit(main())
